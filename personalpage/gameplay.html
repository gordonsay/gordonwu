<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GJ | 遊戲</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style_personal.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../icon/favicon-16x16.png">
    <link rel="manifest" href="../icon/site.webmanifest">
    <style>
        body {
            background-color: rgba(0, 105, 148, 0.7);
        }
        .content-wrapper {
            background-color: rgba(0, 0, 0, 0.6);
            min-height: 100vh;
            padding-top: 60px;
        }
        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .game-container {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        .game-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: white;
        }
        #clickCounter, #timerDisplay {
            font-size: 2rem;
            font-weight: bold;
            color: white;
        }
        .game-controls {
            margin-top: 10px;
            text-align: center;
        }
        .chess-board {
            width: 320px;
            height: 320px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
        }
        .chess-square.white {
            background-color: #f0d9b5;
        }
        .chess-square.black {
            background-color: #b58863;
        }
        .game-container canvas {
            border: 2px solid white;
            max-width: 100%;
            height: auto;
        }
        .navbar {
            background-color: rgba(0, 0, 0, 0.7);
        }
        @media (max-width: 768px) {
            .game-container {
                min-height: 300px;
            }
        }
    </style>
</head>
<body>

<!-- 導航欄 -->
<nav class="navbar navbar-expand-lg navbar-dark fixed-top">
  <div class="container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav ms-lg-3">
        <li class="nav-item">
          <a class="nav-link text-white" href="index_personal.html">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="eat.html">Eat</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="travel.html">Travel</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="box.html">Video</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white active" aria-current="page" href="#">Game</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="note.html">Note</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="content-wrapper">
    <div class="container">
        <h1 class="text-center text-white mb-4">Game Center</h1>
        <div class="game-grid">
            <!-- Number Guessing Game -->
            <div class="game-container">
                <h2 class="game-title">Number Guessing Game</h2>
                <p class="text-white">Guess a number between 1 and 100</p>
                <input type="number" id="guessNumberInput" class="form-control mb-2" min="1" max="100">
                <button onclick="guessNumber()" class="btn btn-primary">Guess!</button>
                <p id="guessResult" class="text-white mt-2"></p>
            </div>
            <!-- Click Speed Game -->
            <div class="game-container">
                <h2 class="game-title">Click Speed Game</h2>
                <p class="text-white">Click the button as many times as possible in 10 seconds</p>
                <button id="clickButton" class="btn btn-primary" onclick="clickSpeedGame()">Click me!</button>
                <p id="clickCounter" class="text-white mt-2">0</p>
                <p id="timerDisplay" class="text-white">10</p>
                <button id="startClickSpeedButton" onclick="startGame('clickSpeed')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- Rock Paper Scissors Game -->
            <div class="game-container">
                <h2 class="game-title">Rock Paper Scissors</h2>
                <p class="text-white">Choose your move:</p>
                <div>
                    <button class="btn btn-light" onclick="playRPS('Rock')">Rock</button>
                    <button class="btn btn-light" onclick="playRPS('Scissors')">Scissors</button>
                    <button class="btn btn-light" onclick="playRPS('Paper')">Paper</button>
                </div>
                <p id="rpsResult" class="text-white mt-3"></p>
            </div>
            <!-- 2048 Game -->
            <div class="game-container">
                <h2 class="game-title">2048 Game</h2>
                <canvas id="2048Canvas" width="300" height="300"></canvas>
                <button id="start2048Button" onclick="startGame('2048')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- Snake Game -->
            <div class="game-container">
                <h2 class="game-title">Snake Game</h2>
                <canvas id="snakeCanvas" width="300" height="300"></canvas>
                <button onclick="startGame('snake')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- Tetris Game -->
            <div class="game-container">
                <h2 class="game-title">Tetris</h2>
                <canvas id="tetrisCanvas" width="240" height="400"></canvas>
                <button id="startTetrisButton" onclick="startGame('tetris')" class="btn btn-primary mt-2">Start Game</button>
            </div>
        </div>
        <!-- Add this new div for displaying scores -->
        <div id="scoresContainer" class="mt-4 text-white"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script>
// Firebase 配置
const firebaseConfig = {
    apiKey: "AIzaSyAy3wt6h_7zLz946XmAZIFFJAFPCkWUCLk",
    authDomain: "test-c338f.firebaseapp.com",
    projectId: "test-c338f",
    storageBucket: "test-c338f.appspot.com",
    messagingSenderId: "117988025801",
    appId: "1:117988025801:web:e95e3c918b8fb9c0e63418",
    measurementId: "G-VYK0LHZ950"
};

// 初始化 Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// 公共遊戲邏輯和事件監���器
let activeGame = null;
let gameStates = {
    'guessNumber': false,
    'clickSpeed': false,
    '2048': false,
    'snake': false,
    'tetris': false
};

function initializeGameListeners() {
    document.addEventListener('keydown', function(e) {
        if (activeGame) {
            // 防止方向鍵滾動頁面
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            
            // 根據當前激活遊戲處理按鍵事件
            switch(activeGame) {
                case 'tetris':
                    handleTetrisKeyPress(e);
                    break;
                case 'snake':
                    handleSnakeKeyPress(e);
                    break;
                case '2048':
                    handle2048KeyPress(e);
                    break;
            }
        }
    });
}

initializeGameListeners();

// 在全局範圍內定義變量
let clickInterval;

// 添加 clickSpeedGame 函數
function clickSpeedGame() {
    if (gameStates['clickSpeed'] && clickTimer > 0) {
        clickCount++;
        document.getElementById('clickCounter').textContent = clickCount;
    }
}

// 確保 startGame 函數在 HTML 元素之前定義
function startGame(gameName) {
    if (gameStates[gameName]) return; // 如果遊戲已經在進行中，則不做任何操作
    
    // 結束其他正在進行的遊戲
    for (let game in gameStates) {
        if (gameStates[game]) {
            endGame(game);
        }
    }
    
    activeGame = gameName;
    gameStates[gameName] = true;
    const startButton = document.getElementById(`start${gameName}Button`);
    if (startButton) {
        startButton.disabled = true;
    }
    
    switch(gameName) {
        case 'guessNumber':
            startGuessNumberGame();
            break;
        case 'clickSpeed':
            startClickSpeedGame();
            break;
        case '2048':
            start2048Game();
            break;
        case 'snake':
            startSnakeGame();
            break;
        case 'tetris':
            startTetrisGame();
            break;
    }
}

// 確保 startSnakeGame 函數被正確定義
function startSnakeGame() {
    activeGame = 'snake';
    const canvas = document.getElementById('snakeCanvas');
    canvas.focus();
    snake = [{x: 200, y: 200}];
    food = getRandomFood();
    snakeDirection = 'RIGHT';
    clearInterval(snakeInterval);
    snakeInterval = setInterval(() => updateSnakeGame(), 100);
}

// 修改 endGame 函數
function endGame(gameName) {
    gameStates[gameName] = false;
    const startButton = document.getElementById(`start${gameName}Button`);
    if (startButton) {
        startButton.disabled = false;
    }
    
    switch(gameName) {
        case 'guessNumber':
            // 重置猜數字遊戲
            targetNumber = Math.floor(Math.random() * 100) + 1;
            guessCount = 0;
            document.getElementById('guessResult').textContent = '';
            break;
        case 'clickSpeed':
            clearInterval(clickInterval);
            break;
        case '2048':
            // 2048遊戲不需要特殊處理
            break;
        case 'snake':
            clearInterval(snakeInterval);
            break;
        case 'tetris':
            clearInterval(tetrisInterval);
            break;
    }
    
    if (gameName === activeGame) {
        activeGame = null;
        document.activeElement.blur();
    }
}

// 修改各個遊戲的開始函數
function startGuessNumberGame() {
    targetNumber = Math.floor(Math.random() * 100) + 1;
    guessCount = 0;
    document.getElementById('guessResult').textContent = '';
    document.getElementById('guessNumberInput').value = '';
    document.getElementById('guessNumberInput').focus();
}

function startClickSpeedGame() {
    clickCount = 0;
    clickTimer = 10;
    document.getElementById('clickCounter').textContent = clickCount;
    document.getElementById('timerDisplay').textContent = clickTimer;
    document.getElementById('clickButton').disabled = false;
    clearInterval(clickInterval);
    clickInterval = setInterval(() => {
        clickTimer--;
        document.getElementById('timerDisplay').textContent = clickTimer;
        if (clickTimer <= 0) {
            clearInterval(clickInterval);
            document.getElementById('clickButton').disabled = true;
            alert(`Time's up! You clicked ${clickCount} times.`);
            saveScore('clickSpeed', clickCount);
            endGame('clickSpeed');
        }
    }, 1000);
}

function start2048Game() {
    board2048 = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    addNewTile();
    addNewTile();
    draw2048Board();
}

function startTetrisGame() {
    const canvas = document.getElementById('tetrisCanvas');
    canvas.focus();
    tetrisBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
    currentPiece = getRandomPiece();
    nextPiece = getRandomPiece();
    currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
    currentY = 0;
    clearInterval(tetrisInterval);
    tetrisInterval = setInterval(() => {
        const canvas = document.getElementById('tetrisCanvas');
        updateTetrisGame(canvas.getContext('2d'));
    }, 500);
    drawTetrisBoard(canvas.getContext('2d'));
}

// 修改 HTML 中的按鈕點擊事件
// <button id="startGuessNumberButton" onclick="startGame('guessNumber')" class="btn btn-primary">開始遊戲</button>
// <button id="startClickSpeedButton" onclick="startGame('clickSpeed')" class="btn btn-primary mt-2">開始遊戲</button>
// <button id="start2048Button" onclick="startGame('2048')" class="btn btn-primary mt-2">開始遊戲</button>
// <button id="startSnakeButton" onclick="startGame('snake')" class="btn btn-primary mt-2">開始遊戲</button>
// <button id="startTetrisButton" onclick="startGame('tetris')" class="btn btn-primary mt-2">開始遊戲</button>

// 其他遊戲邏輯保持不變

// 貪吃蛇遊戲邏輯
let snake, food, snakeDirection, snakeInterval;
const SNAKE_BLOCK_SIZE = 15;
const SNAKE_CANVAS_WIDTH = 300;
const SNAKE_CANVAS_HEIGHT = 300;

function getRandomFood() {
    return {
        x: Math.floor(Math.random() * (SNAKE_CANVAS_WIDTH / SNAKE_BLOCK_SIZE)) * SNAKE_BLOCK_SIZE,
        y: Math.floor(Math.random() * (SNAKE_CANVAS_HEIGHT / SNAKE_BLOCK_SIZE)) * SNAKE_BLOCK_SIZE
    };
}

function updateSnakeGame() {
    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 移動蛇
    const head = {...snake[0]};
    if (snakeDirection === 'RIGHT') head.x += SNAKE_BLOCK_SIZE;
    if (snakeDirection === 'LEFT') head.x -= SNAKE_BLOCK_SIZE;
    if (snakeDirection === 'UP') head.y -= SNAKE_BLOCK_SIZE;
    if (snakeDirection === 'DOWN') head.y += SNAKE_BLOCK_SIZE;
    
    // 檢查碰撞
    if (head.x < 0 || head.x >= SNAKE_CANVAS_WIDTH || head.y < 0 || head.y >= SNAKE_CANVAS_HEIGHT || snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        clearInterval(snakeInterval);
        alert('Game Over!');
        endGame('snake');
        return;
    }
    
    snake.unshift(head);
    
    // 檢查是否吃到食物
    if (head.x === food.x && head.y === food.y) {
        food = getRandomFood();
    } else {
        snake.pop();
    }
    
    // 繪製蛇和食物
    ctx.fillStyle = 'green';
    snake.forEach(segment => ctx.fillRect(segment.x, segment.y, SNAKE_BLOCK_SIZE - 1, SNAKE_BLOCK_SIZE - 1));
    ctx.fillStyle = 'red';
    ctx.fillRect(food.x, food.y, SNAKE_BLOCK_SIZE - 1, SNAKE_BLOCK_SIZE - 1);
}

function handleSnakeKeyPress(e) {
    if (activeGame !== 'snake') return;
    
    if (e.key === 'ArrowUp' && snakeDirection !== 'DOWN') snakeDirection = 'UP';
    if (e.key === 'ArrowDown' && snakeDirection !== 'UP') snakeDirection = 'DOWN';
    if (e.key === 'ArrowLeft' && snakeDirection !== 'RIGHT') snakeDirection = 'LEFT';
    if (e.key === 'ArrowRight' && snakeDirection !== 'LEFT') snakeDirection = 'RIGHT';
}

// 2048遊戲邏輯
const GRID_SIZE = 4;
let board2048;

function start2048Game() {
    board2048 = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    addNewTile();
    addNewTile();
    draw2048Board();
}

function addNewTile() {
    let available = [];
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            if (board2048[i][j] === 0) {
                available.push({x: i, y: j});
            }
        }
    }
    if (available.length > 0) {
        let spot = available[Math.floor(Math.random() * available.length)];
        board2048[spot.x][spot.y] = Math.random() < 0.9 ? 2 : 4;
    }
}

function draw2048Board() {
    const canvas = document.getElementById('2048Canvas');
    const ctx = canvas.getContext('2d');
    const tileSize = canvas.width / GRID_SIZE;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
            const value = board2048[row][col];
            ctx.fillStyle = getTileColor(value);
            ctx.fillRect(col * tileSize, row * tileSize, tileSize - 2, tileSize - 2);
            if (value !== 0) {
                ctx.fillStyle = '#776e65';
                ctx.font = `${tileSize / 3}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(value, (col + 0.5) * tileSize, (row + 0.6) * tileSize);
            }
        }
    }
}

function getTileColor(value) {
    switch (value) {
        case 2: return '#eee4da';
        case 4: return '#ede0c8';
        case 8: return '#f2b179';
        case 16: return '#f59563';
        case 32: return '#f67c5f';
        case 64: return '#f65e3b';
        case 128: return '#edcf72';
        case 256: return '#edcc61';
        case 512: return '#edc850';
        case 1024: return '#edc53f';
        case 2048: return '#edc22e';
        default: return '#cdc1b4';
    }
}

function handle2048KeyPress(e) {
    if (activeGame !== '2048') return;
    
    let moved = false;
    switch(e.key) {
        case 'ArrowUp':
            moved = moveUp();
            break;
        case 'ArrowDown':
            moved = moveDown();
            break;
        case 'ArrowLeft':
            moved = moveLeft();
            break;
        case 'ArrowRight':
            moved = moveRight();
            break;
    }
    
    if (moved) {
        addNewTile();
        draw2048Board();
        if (isGameOver()) {
            alert('Game Over!');
            endGame('2048');
        }
    }
}

function moveUp() {
    let moved = false;
    for (let col = 0; col < GRID_SIZE; col++) {
        for (let row = 1; row < GRID_SIZE; row++) {
            if (board2048[row][col] !== 0) {
                let currentRow = row;
                while (currentRow > 0 && (board2048[currentRow - 1][col] === 0 || board2048[currentRow - 1][col] === board2048[currentRow][col])) {
                    if (board2048[currentRow - 1][col] === 0) {
                        board2048[currentRow - 1][col] = board2048[currentRow][col];
                        board2048[currentRow][col] = 0;
                        currentRow--;
                        moved = true;
                    } else if (board2048[currentRow - 1][col] === board2048[currentRow][col]) {
                        board2048[currentRow - 1][col] *= 2;
                        board2048[currentRow][col] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function moveDown() {
    let moved = false;
    for (let col = 0; col < GRID_SIZE; col++) {
        for (let row = GRID_SIZE - 2; row >= 0; row--) {
            if (board2048[row][col] !== 0) {
                let currentRow = row;
                while (currentRow < GRID_SIZE - 1 && (board2048[currentRow + 1][col] === 0 || board2048[currentRow + 1][col] === board2048[currentRow][col])) {
                    if (board2048[currentRow + 1][col] === 0) {
                        board2048[currentRow + 1][col] = board2048[currentRow][col];
                        board2048[currentRow][col] = 0;
                        currentRow++;
                        moved = true;
                    } else if (board2048[currentRow + 1][col] === board2048[currentRow][col]) {
                        board2048[currentRow + 1][col] *= 2;
                        board2048[currentRow][col] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function moveLeft() {
    let moved = false;
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 1; col < GRID_SIZE; col++) {
            if (board2048[row][col] !== 0) {
                let currentCol = col;
                while (currentCol > 0 && (board2048[row][currentCol - 1] === 0 || board2048[row][currentCol - 1] === board2048[row][currentCol])) {
                    if (board2048[row][currentCol - 1] === 0) {
                        board2048[row][currentCol - 1] = board2048[row][currentCol];
                        board2048[row][currentCol] = 0;
                        currentCol--;
                        moved = true;
                    } else if (board2048[row][currentCol - 1] === board2048[row][currentCol]) {
                        board2048[row][currentCol - 1] *= 2;
                        board2048[row][currentCol] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function moveRight() {
    let moved = false;
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = GRID_SIZE - 2; col >= 0; col--) {
            if (board2048[row][col] !== 0) {
                let currentCol = col;
                while (currentCol < GRID_SIZE - 1 && (board2048[row][currentCol + 1] === 0 || board2048[row][currentCol + 1] === board2048[row][currentCol])) {
                    if (board2048[row][currentCol + 1] === 0) {
                        board2048[row][currentCol + 1] = board2048[row][currentCol];
                        board2048[row][currentCol] = 0;
                        currentCol++;
                        moved = true;
                    } else if (board2048[row][currentCol + 1] === board2048[row][currentCol]) {
                        board2048[row][currentCol + 1] *= 2;
                        board2048[row][currentCol] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function isGameOver() {
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            if (board2048[i][j] === 0) return false;
            if (i < GRID_SIZE - 1 && board2048[i][j] === board2048[i + 1][j]) return false;
            if (j < GRID_SIZE - 1 && board2048[i][j] === board2048[i][j + 1]) return false;
        }
    }
    return true;
}

// 俄羅斯方塊遊戲邏輯
let tetrisBoard, currentPiece, nextPiece, tetrisInterval, currentX, currentY;
const TETRIS_BLOCK_SIZE = 20;
const BOARD_WIDTH = 12;
const BOARD_HEIGHT = 20;

function startTetrisGame() {
    const canvas = document.getElementById('tetrisCanvas');
    canvas.width = BOARD_WIDTH * TETRIS_BLOCK_SIZE;
    canvas.height = BOARD_HEIGHT * TETRIS_BLOCK_SIZE;
    canvas.focus();
    tetrisBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
    currentPiece = getRandomPiece();
    nextPiece = getRandomPiece();
    currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
    currentY = 0;
    clearInterval(tetrisInterval);
    tetrisInterval = setInterval(() => {
        const canvas = document.getElementById('tetrisCanvas');
        updateTetrisGame(canvas.getContext('2d'));
    }, 500);
    drawTetrisBoard(canvas.getContext('2d'));
}

function getRandomPiece() {
    const pieces = [
        [[1,1,1,1]],
        [[1,1],[1,1]],
        [[1,1,1],[0,1,0]],
        [[1,1,1],[1,0,0]],
        [[1,1,1],[0,0,1]],
        [[1,1,0],[0,1,1]],
        [[0,1,1],[1,1,0]]
    ];
    return pieces[Math.floor(Math.random() * pieces.length)];
}

function drawTetrisBoard(ctx) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // 繪製已放置的方塊
    for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            if (tetrisBoard[y][x]) {
                ctx.fillStyle = 'blue';
                ctx.fillRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
            }
        }
    }
    
    // 繪製當前方塊
    ctx.fillStyle = 'red';
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x]) {
                ctx.fillRect((x + currentX) * TETRIS_BLOCK_SIZE, (y + currentY) * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
            }
        }
    }
}

function updateTetrisGame(ctx) {
    if (!canMovePieceDown()) {
        placePiece();
    } else {
        currentY++;
    }
    drawTetrisBoard(ctx);
}

function handleTetrisKeyPress(e) {
    if (activeGame !== 'tetris') return;
    
    switch(e.key) {
        case 'ArrowLeft':
            moveTetrisPieceLeft();
            break;
        case 'ArrowRight':
            moveTetrisPieceRight();
            break;
        case 'ArrowDown':
            moveTetrisPieceDown();
            break;
        case 'ArrowUp':
            rotateTetrisPiece();
            break;
    }
    
    const canvas = document.getElementById('tetrisCanvas');
    drawTetrisBoard(canvas.getContext('2d'));
}

// 添加這些輔助函數
function moveTetrisPieceLeft() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x] && (x + currentX - 1 < 0 || tetrisBoard[y + currentY][x + currentX - 1])) {
                return;
            }
        }
    }
    currentX--;
}

function moveTetrisPieceRight() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x] && (x + currentX + 1 >= BOARD_WIDTH || tetrisBoard[y + currentY][x + currentX + 1])) {
                return;
            }
        }
    }
    currentX++;
}

function moveTetrisPieceDown() {
    if (!canMovePieceDown()) {
        placePiece();
        return;
    }
    currentY++;
}

function rotateTetrisPiece() {
    const rotatedPiece = currentPiece[0].map((val, index) => currentPiece.map(row => row[index]).reverse());
    if (canPieceFit(rotatedPiece, currentX, currentY)) {
        currentPiece = rotatedPiece;
    }
}

function canMovePieceDown() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x] && (y + currentY + 1 >= BOARD_HEIGHT || tetrisBoard[y + currentY + 1][x + currentX])) {
                return false;
            }
        }
    }
    return true;
}

function canPieceFit(piece, x, y) {
    for (let pieceY = 0; pieceY < piece.length; pieceY++) {
        for (let pieceX = 0; pieceX < piece[pieceY].length; pieceX++) {
            if (piece[pieceY][pieceX]) {
                if (pieceX + x < 0 || pieceX + x >= BOARD_WIDTH || pieceY + y >= BOARD_HEIGHT || tetrisBoard[pieceY + y][pieceX + x]) {
                    return false;
                }
            }
        }
    }
    return true;
}

function placePiece() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x]) {
                tetrisBoard[y + currentY][x + currentX] = 1;
            }
        }
    }
    clearLines();
    currentPiece = nextPiece;
    nextPiece = getRandomPiece();
    currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
    currentY = 0;
    if (!canPieceFit(currentPiece, currentX, currentY)) {
        endGame('tetris');
    }
}

function clearLines() {
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (tetrisBoard[y].every(cell => cell !== 0)) {
            tetrisBoard.splice(y, 1);
            tetrisBoard.unshift(Array(BOARD_WIDTH).fill(0));
        }
    }
}

// 添加 guessNumber 函數
let targetNumber, guessCount;

function guessNumber() {
    const guess = parseInt(document.getElementById('guessNumberInput').value);
    guessCount++;
    
    if (guess === targetNumber) {
        document.getElementById('guessResult').textContent = `Congratulations! You guessed it in ${guessCount} tries.`;
        saveScore('guessNumber', guessCount);
        endGame('guessNumber');
    } else if (guess < targetNumber) {
        document.getElementById('guessResult').textContent = 'Too low, guess higher!';
    } else {
        document.getElementById('guessResult').textContent = 'Too high, guess lower!';
    }
}

// 添加 playRPS 函數
function playRPS(playerChoice) {
    const choices = ['Rock', 'Scissors', 'Paper'];
    const computerChoice = choices[Math.floor(Math.random() * 3)];
    
    let result;
    if (playerChoice === computerChoice) {
        result = 'It\'s a tie!';
    } else if (
        (playerChoice === 'Rock' && computerChoice === 'Scissors') ||
        (playerChoice === 'Scissors' && computerChoice === 'Paper') ||
        (playerChoice === 'Paper' && computerChoice === 'Rock')
    ) {
        result = 'You win!';
    } else {
        result = 'Computer wins!';
    }
    
    document.getElementById('rpsResult').textContent = `You chose ${playerChoice}, computer chose ${computerChoice}. ${result}`;
}
</script>
</body>
</html>
