<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GJ | Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style_personal.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../icon/favicon-16x16.png">
    <link rel="manifest" href="../icon/site.webmanifest">
    <style>
        body {
            background-color: rgba(0, 105, 148, 0.7);
        }
        .content-wrapper {
            background-color: rgba(0, 0, 0, 0.6);
            min-height: 100vh;
            padding-top: 60px;
        }
        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .game-container {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        .game-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: white;
        }
        #clickCounter, #timerDisplay {
            font-size: 2rem;
            font-weight: bold;
            color: white;
        }
        .game-controls {
            margin-top: 10px;
            text-align: center;
        }
        .chess-board {
            width: 320px;
            height: 320px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
        }
        .chess-square.white {
            background-color: #f0d9b5;
        }
        .chess-square.black {
            background-color: #b58863;
        }
        .game-container canvas {
            border: 2px solid white;
            max-width: 100%;
            height: auto;
        }
        .navbar {
            background-color: rgba(0, 0, 0, 0.7);
        }
        @media (max-width: 768px) {
            .game-container {
                min-height: 300px;
            }
        }
        .virtual-keyboard {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        .virtual-keyboard button {
            margin: 0 5px;
            padding: 10px;
            font-size: 18px;
        }
    </style>
</head>
<body>

<!-- 導航欄 -->
<nav class="navbar navbar-expand-lg navbar-dark fixed-top">
  <div class="container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav ms-lg-3">
        <li class="nav-item">
          <a class="nav-link text-white" href="index_personal.html">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="eat.html">Eat</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="travel.html">Travel</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="box.html">Video</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white active" aria-current="page" href="#">Game</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="note.html">Note</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="gift.html">Gift</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="content-wrapper">
    <div class="container">
        <h1 class="text-center text-white mb-4">Game Center</h1>
        <div class="game-grid">
            <!-- Number Guessing Game -->
            <div class="game-container">
                <h2 class="game-title">Number Guessing Game</h2>
                <p class="text-white">Guess a number between 1 and 100</p>
                <input type="number" id="guessNumberInput" class="form-control mb-2" min="1" max="100">
                <button onclick="guessNumber()" class="btn btn-primary">Guess!</button>
                <p id="guessResult" class="text-white mt-2"></p>
                <input type="text" id="guessNumberId" placeholder="Enter your ID" class="form-control mt-2">
                <button onclick="startGame('guessNumber')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- Click Speed Game -->
            <div class="game-container">
                <h2 class="game-title">Click Speed Game</h2>
                <p class="text-white">Click the button as many times as possible in 10 seconds</p>
                <button id="clickButton" class="btn btn-primary" onclick="clickSpeedGame()">Click me!</button>
                <p id="clickCounter" class="text-white mt-2">0</p>
                <p id="timerDisplay" class="text-white">10</p>
                <input type="text" id="clickSpeedId" placeholder="Enter your ID" class="form-control mt-2">
                <button id="startClickSpeedButton" onclick="startGame('clickSpeed')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- Rock Paper Scissors Game -->
            <div class="game-container">
                <h2 class="game-title">Rock Paper Scissors</h2>
                <p class="text-white">Choose your move:</p>
                <div>
                    <button class="btn btn-light" onclick="playRPS('Rock')">Rock</button>
                    <button class="btn btn-light" onclick="playRPS('Scissors')">Scissors</button>
                    <button class="btn btn-light" onclick="playRPS('Paper')">Paper</button>
                </div>
                <p id="rpsResult" class="text-white mt-3"></p>
                <input type="text" id="rpsId" placeholder="Enter your ID" class="form-control mt-2">
            </div>
            <!-- 2048 Game -->
            <div class="game-container">
                <h2 class="game-title">2048 Game</h2>
                <canvas id="2048Canvas" width="300" height="300"></canvas>
                <div class="virtual-keyboard">
                    <button onclick="handle2048KeyPress({key:'ArrowUp'})">↑</button>
                    <button onclick="handle2048KeyPress({key:'ArrowLeft'})">←</button>
                    <button onclick="handle2048KeyPress({key:'ArrowDown'})">↓</button>
                    <button onclick="handle2048KeyPress({key:'ArrowRight'})">→</button>
                </div>
                <input type="text" id="2048Id" placeholder="Enter your ID" class="form-control mt-2">
                <button id="start2048Button" onclick="startGame('2048')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- Snake Game -->
            <div class="game-container">
                <h2 class="game-title">Snake Game</h2>
                <canvas id="snakeCanvas" width="300" height="300"></canvas>
                <div class="virtual-keyboard">
                    <button onclick="handleSnakeKeyPress({key:'ArrowUp'})">↑</button>
                    <button onclick="handleSnakeKeyPress({key:'ArrowLeft'})">←</button>
                    <button onclick="handleSnakeKeyPress({key:'ArrowDown'})">↓</button>
                    <button onclick="handleSnakeKeyPress({key:'ArrowRight'})">→</button>
                </div>
                <input type="text" id="snakeId" placeholder="Enter your ID" class="form-control mt-2">
                <button onclick="startGame('snake')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- Tetris Game -->
            <div class="game-container">
                <h2 class="game-title">Tetris</h2>
                <canvas id="tetrisCanvas" width="240" height="400"></canvas>
                <div class="virtual-keyboard">
                    <button onclick="handleTetrisKeyPress({key:'ArrowUp'})">Rotate</button>
                    <button onclick="handleTetrisKeyPress({key:'ArrowLeft'})">←</button>
                    <button onclick="handleTetrisKeyPress({key:'ArrowDown'})">↓</button>
                    <button onclick="handleTetrisKeyPress({key:'ArrowRight'})">→</button>
                </div>
                <input type="text" id="tetrisId" placeholder="Enter your ID" class="form-control mt-2">
                <button id="startTetrisButton" onclick="startGame('tetris')" class="btn btn-primary mt-2">Start Game</button>
            </div>
            <!-- 口袋妖怪皮卡丘版遊戲容器 -->
            <div class="game-container">
                <h2 class="game-title">PKM-Yellow</h2>
                <iframe src="https://www.retrogames.cc/embed/18569-pocket-monsters-pikachu-japan.html" width="300" height="280" frameborder="no" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true" scrolling="no"></iframe>
            </div>

            <!-- 口袋妖怪紅色版遊戲容器 -->
            <div class="game-container">
                <h2 class="game-title">PKM-RED</h2>
                <iframe src="https://www.retrogames.cc/embed/44577-pokemon-red-full-color-hack.html" width="300" height="280" frameborder="no" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true" scrolling="no"></iframe>
            </div>

            <!-- 口袋妖怪完美水晶版遊戲容器 -->
            <div class="game-container">
                <h2 class="game-title">PKM-Crystal</h2>
                <iframe src="https://www.retrogames.cc/embed/44705-pokemon-perfect-crystal-2020-update.html" width="300" height="280" frameborder="no" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true" scrolling="no"></iframe>
            </div>

            <!-- 口袋妖怪超越版遊戲容器 -->
            <div class="game-container">
                <h2 class="game-title">PKM-Exceeded</h2>
                <iframe src="https://www.retrogames.cc/embed/45833-pokemon-exceeded-v11-1.html" width="300" height="280" frameborder="no" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true" scrolling="no"></iframe>
            </div>

            <!-- 新增的 One Piece 遊戲容器 -->
            <div class="game-container">
                <h2 class="game-title">OnePiece Going Baseball</h2>
                <iframe src="https://www.retrogames.cc/embed/19491-one-piece-going-baseball-j-eurasia.html" width="300" height="280" frameborder="no" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true" scrolling="no"></iframe>
            </div>
        </div>
        <!-- Add this new div for displaying scores -->
        <div id="scoresContainer" class="mt-4 text-white"></div>
    </div>
</div>

<div class="container mt-5">
    <h2 class="text-center text-white">Score Table</h2>
    <table class="table table-dark table-striped">
        <thead>
            <tr>
                <th>Game</th>
                <th>ID</th>
                <th>Score</th>
            </tr>
        </thead>
        <tbody id="scoreTableBody">
            <!-- 分數將通過 JavaScript 動態添加 -->
        </tbody>
    </table>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script>
// Firebase 配置
const firebaseConfig = {
    apiKey: "AIzaSyAy3wt6h_7zLz946XmAZIFFJAFPCkWUCLk",
    authDomain: "test-c338f.firebaseapp.com",
    projectId: "test-c338f",
    storageBucket: "test-c338f.appspot.com",
    messagingSenderId: "117988025801",
    appId: "1:117988025801:web:e95e3c918b8fb9c0e63418",
    measurementId: "G-VYK0LHZ950"
};

// 初始化 Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// 公共遊戲邏輯和事件監聽器
let activeGame = null;
let gameStates = {
    'guessNumber': false,
    'clickSpeed': false,
    '2048': false,
    'snake': false,
    'tetris': false
};

function initializeGameListeners() {
    document.addEventListener('keydown', function(e) {
        if (activeGame) {
            // 防止方向鍵滾動頁面
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            
            // 根據當前激活遊戲處理按鍵事件
            switch(activeGame) {
                case 'tetris':
                    handleTetrisKeyPress(e);
                    break;
                case 'snake':
                    handleSnakeKeyPress(e);
                    break;
                case '2048':
                    handle2048KeyPress(e);
                    break;
            }
        }
    });
}

initializeGameListeners();

// 在全局範圍內定義變量
let clickInterval;

// 添加 clickSpeedGame 函數
function clickSpeedGame() {
    if (gameStates['clickSpeed'] && clickTimer > 0) {
        clickCount++;
        document.getElementById('clickCounter').textContent = clickCount;
    }
}

// 確保 startGame 函數在 HTML 元素之前定義
function startGame(gameName) {
    if (gameStates[gameName]) return; // 如果遊戲已經在進行中，則不做任何操作
    
    // 結束其他正在進行的遊戲
    for (let game in gameStates) {
        if (gameStates[game]) {
            endGame(game);
        }
    }
    
    activeGame = gameName;
    gameStates[gameName] = true;
    const startButton = document.getElementById(`start${gameName}Button`);
    if (startButton) {
        startButton.disabled = true;
    }
    
    switch(gameName) {
        case 'guessNumber':
            startGuessNumberGame();
            break;
        case 'clickSpeed':
            startClickSpeedGame();
            break;
        case '2048':
            start2048Game();
            break;
        case 'snake':
            startSnakeGame();
            break;
        case 'tetris':
            startTetrisGame();
            break;
    }
}

// 貪吃蛇遊戲邏輯
let snake, food, snakeDirection, snakeInterval;
const SNAKE_BLOCK_SIZE = 15;
const SNAKE_CANVAS_WIDTH = 300;
const SNAKE_CANVAS_HEIGHT = 300;

function startSnakeGame() {
    const canvas = document.getElementById('snakeCanvas');
    canvas.width = SNAKE_CANVAS_WIDTH;
    canvas.height = SNAKE_CANVAS_HEIGHT;
    canvas.focus();
    snake = [{x: 150, y: 150}];
    food = getRandomFood();
    snakeDirection = 'RIGHT';
    clearInterval(snakeInterval);
    snakeInterval = setInterval(updateSnakeGame, 100);
}

function getRandomFood() {
    return {
        x: Math.floor(Math.random() * (SNAKE_CANVAS_WIDTH / SNAKE_BLOCK_SIZE)) * SNAKE_BLOCK_SIZE,
        y: Math.floor(Math.random() * (SNAKE_CANVAS_HEIGHT / SNAKE_BLOCK_SIZE)) * SNAKE_BLOCK_SIZE
    };
}

function updateSnakeGame() {
    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 移動蛇
    const head = {...snake[0]};
    switch(snakeDirection) {
        case 'RIGHT': head.x += SNAKE_BLOCK_SIZE; break;
        case 'LEFT': head.x -= SNAKE_BLOCK_SIZE; break;
        case 'UP': head.y -= SNAKE_BLOCK_SIZE; break;
        case 'DOWN': head.y += SNAKE_BLOCK_SIZE; break;
    }
    
    // 檢查碰撞
    if (head.x < 0 || head.x >= SNAKE_CANVAS_WIDTH || head.y < 0 || head.y >= SNAKE_CANVAS_HEIGHT || 
        snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        clearInterval(snakeInterval);
        alert('Game Over! Your score: ' + (snake.length - 1));
        saveScore('snake', snake.length - 1);
        endGame('snake');
        return;
    }
    
    snake.unshift(head);
    
    // 檢查是否吃到食物
    if (head.x === food.x && head.y === food.y) {
        food = getRandomFood();
    } else {
        snake.pop();
    }
    
    // 繪製蛇和食物
    ctx.fillStyle = 'green';
    snake.forEach(segment => ctx.fillRect(segment.x, segment.y, SNAKE_BLOCK_SIZE - 1, SNAKE_BLOCK_SIZE - 1));
    ctx.fillStyle = 'red';
    ctx.fillRect(food.x, food.y, SNAKE_BLOCK_SIZE - 1, SNAKE_BLOCK_SIZE - 1);
}

function handleSnakeKeyPress(e) {
    if (activeGame !== 'snake') return;
    
    switch(e.key) {
        case 'ArrowUp': if (snakeDirection !== 'DOWN') snakeDirection = 'UP'; break;
        case 'ArrowDown': if (snakeDirection !== 'UP') snakeDirection = 'DOWN'; break;
        case 'ArrowLeft': if (snakeDirection !== 'RIGHT') snakeDirection = 'LEFT'; break;
        case 'ArrowRight': if (snakeDirection !== 'LEFT') snakeDirection = 'RIGHT'; break;
    }
}

// 修改 endGame 函數
function endGame(gameName) {
    gameStates[gameName] = false;
    const startButton = document.getElementById(`start${gameName}Button`);
    if (startButton) {
        startButton.disabled = false;
    }
    
    switch(gameName) {
        case 'guessNumber':
            // 重置猜數字遊戲
            targetNumber = Math.floor(Math.random() * 100) + 1;
            guessCount = 0;
            document.getElementById('guessResult').textContent = '';
            break;
        case 'clickSpeed':
            clearInterval(clickInterval);
            break;
        case '2048':
            // 2048遊戲不需要特殊處理
            break;
        case 'snake':
            clearInterval(snakeInterval);
            break;
        case 'tetris':
            clearInterval(tetrisInterval);
            break;
    }
    
    if (gameName === activeGame) {
        activeGame = null;
        document.activeElement.blur();
    }
}

// 修改各個遊戲的開始函數
function startGuessNumberGame() {
    targetNumber = Math.floor(Math.random() * 100) + 1;
    guessCount = 0;
    document.getElementById('guessResult').textContent = '';
    document.getElementById('guessNumberInput').value = '';
    document.getElementById('guessNumberInput').focus();
}

function startClickSpeedGame() {
    clickCount = 0;
    clickTimer = 10;
    document.getElementById('clickCounter').textContent = clickCount;
    document.getElementById('timerDisplay').textContent = clickTimer;
    document.getElementById('clickButton').disabled = false;
    clearInterval(clickInterval);
    clickInterval = setInterval(() => {
        clickTimer--;
        document.getElementById('timerDisplay').textContent = clickTimer;
        if (clickTimer <= 0) {
            clearInterval(clickInterval);
            document.getElementById('clickButton').disabled = true;
            alert(`Time's up! You clicked ${clickCount} times.`);
            saveScore('clickSpeed', clickCount);
            endGame('clickSpeed');
        }
    }, 1000);
}

// 在全局範圍內添加一個變量來跟踪最高分數
let highestScore2048 = 0;

// 修改 start2048Game 函數
function start2048Game() {
    board2048 = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    highestScore2048 = 0; // 重置最高分數
    addNewTile();
    addNewTile();
    draw2048Board();
}

// 修改 handle2048KeyPress 函數
function handle2048KeyPress(e) {
    if (activeGame !== '2048') return;
    
    let moved = false;
    switch(e.key) {
        case 'ArrowUp':
            moved = moveUp();
            break;
        case 'ArrowDown':
            moved = moveDown();
            break;
        case 'ArrowLeft':
            moved = moveLeft();
            break;
        case 'ArrowRight':
            moved = moveRight();
            break;
    }
    
    if (moved) {
        addNewTile();
        updateHighestScore();
        draw2048Board();
        if (isGameOver()) {
            alert('遊戲結束！您的最高分數是：' + highestScore2048);
            saveScore('2048', highestScore2048);
            endGame('2048');
        }
    }
}

// 添加 updateHighestScore 函數
function updateHighestScore() {
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
            if (board2048[row][col] > highestScore2048) {
                highestScore2048 = board2048[row][col];
            }
        }
    }
}

// 修改移動函數（moveUp, moveDown, moveLeft, moveRight）
// 這裡以 moveUp 為例，其他函數也需要類似修改
function moveUp() {
    let moved = false;
    for (let col = 0; col < GRID_SIZE; col++) {
        for (let row = 1; row < GRID_SIZE; row++) {
            if (board2048[row][col] !== 0) {
                let currentRow = row;
                while (currentRow > 0 && (board2048[currentRow - 1][col] === 0 || board2048[currentRow - 1][col] === board2048[currentRow][col])) {
                    if (board2048[currentRow - 1][col] === 0) {
                        board2048[currentRow - 1][col] = board2048[currentRow][col];
                        board2048[currentRow][col] = 0;
                        currentRow--;
                        moved = true;
                    } else if (board2048[currentRow - 1][col] === board2048[currentRow][col]) {
                        board2048[currentRow - 1][col] *= 2;
                        board2048[currentRow][col] = 0;
                        moved = true;
                        // 更新最高分數
                        if (board2048[currentRow - 1][col] > highestScore2048) {
                            highestScore2048 = board2048[currentRow - 1][col];
                        }
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

// 其他移動函數（moveDown, moveLeft, moveRight）也需要類似的修改

function startTetrisGame() {
    const canvas = document.getElementById('tetrisCanvas');
    canvas.focus();
    tetrisBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
    currentPiece = getRandomPiece();
    nextPiece = getRandomPiece();
    currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
    currentY = 0;
    clearInterval(tetrisInterval);
    tetrisInterval = setInterval(() => {
        const canvas = document.getElementById('tetrisCanvas');
        updateTetrisGame(canvas.getContext('2d'));
    }, 500);
    drawTetrisBoard(canvas.getContext('2d'));
}

// 修改 HTML 中的按鈕點擊事件
// <button id="startGuessNumberButton" onclick="startGame('guessNumber')" class="btn btn-primary">開始遊戲</button>
// <button id="startClickSpeedButton" onclick="startGame('clickSpeed')" class="btn btn-primary mt-2">開始遊戲</button>
// <button id="start2048Button" onclick="startGame('2048')" class="btn btn-primary mt-2">開始遊戲</button>
// <button id="startSnakeButton" onclick="startGame('snake')" class="btn btn-primary mt-2">開始遊戲</button>
// <button id="startTetrisButton" onclick="startGame('tetris')" class="btn btn-primary mt-2">開始遊戲</button>

// 其他遊戲邏輯保持不變

// 2048遊戲邏輯
const GRID_SIZE = 4;
let board2048;

function start2048Game() {
    board2048 = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    addNewTile();
    addNewTile();
    draw2048Board();
}

function addNewTile() {
    let available = [];
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            if (board2048[i][j] === 0) {
                available.push({x: i, y: j});
            }
        }
    }
    if (available.length > 0) {
        let spot = available[Math.floor(Math.random() * available.length)];
        board2048[spot.x][spot.y] = Math.random() < 0.9 ? 2 : 4;
    }
}

function draw2048Board() {
    const canvas = document.getElementById('2048Canvas');
    const ctx = canvas.getContext('2d');
    const tileSize = canvas.width / GRID_SIZE;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
            const value = board2048[row][col];
            ctx.fillStyle = getTileColor(value);
            ctx.fillRect(col * tileSize, row * tileSize, tileSize - 2, tileSize - 2);
            if (value !== 0) {
                ctx.fillStyle = '#776e65';
                ctx.font = `${tileSize / 3}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(value, (col + 0.5) * tileSize, (row + 0.6) * tileSize);
            }
        }
    }
}

function getTileColor(value) {
    switch (value) {
        case 2: return '#eee4da';
        case 4: return '#ede0c8';
        case 8: return '#f2b179';
        case 16: return '#f59563';
        case 32: return '#f67c5f';
        case 64: return '#f65e3b';
        case 128: return '#edcf72';
        case 256: return '#edcc61';
        case 512: return '#edc850';
        case 1024: return '#edc53f';
        case 2048: return '#edc22e';
        default: return '#cdc1b4';
    }
}

function handle2048KeyPress(e) {
    if (activeGame !== '2048') return;
    
    let moved = false;
    switch(e.key) {
        case 'ArrowUp':
            moved = moveUp();
            break;
        case 'ArrowDown':
            moved = moveDown();
            break;
        case 'ArrowLeft':
            moved = moveLeft();
            break;
        case 'ArrowRight':
            moved = moveRight();
            break;
    }
    
    if (moved) {
        addNewTile();
        draw2048Board();
        if (isGameOver()) {
            alert('Game Over!');
            endGame('2048');
        }
    }
}

function moveUp() {
    let moved = false;
    for (let col = 0; col < GRID_SIZE; col++) {
        for (let row = 1; row < GRID_SIZE; row++) {
            if (board2048[row][col] !== 0) {
                let currentRow = row;
                while (currentRow > 0 && (board2048[currentRow - 1][col] === 0 || board2048[currentRow - 1][col] === board2048[currentRow][col])) {
                    if (board2048[currentRow - 1][col] === 0) {
                        board2048[currentRow - 1][col] = board2048[currentRow][col];
                        board2048[currentRow][col] = 0;
                        currentRow--;
                        moved = true;
                    } else if (board2048[currentRow - 1][col] === board2048[currentRow][col]) {
                        board2048[currentRow - 1][col] *= 2;
                        board2048[currentRow][col] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function moveDown() {
    let moved = false;
    for (let col = 0; col < GRID_SIZE; col++) {
        for (let row = GRID_SIZE - 2; row >= 0; row--) {
            if (board2048[row][col] !== 0) {
                let currentRow = row;
                while (currentRow < GRID_SIZE - 1 && (board2048[currentRow + 1][col] === 0 || board2048[currentRow + 1][col] === board2048[currentRow][col])) {
                    if (board2048[currentRow + 1][col] === 0) {
                        board2048[currentRow + 1][col] = board2048[currentRow][col];
                        board2048[currentRow][col] = 0;
                        currentRow++;
                        moved = true;
                    } else if (board2048[currentRow + 1][col] === board2048[currentRow][col]) {
                        board2048[currentRow + 1][col] *= 2;
                        board2048[currentRow][col] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function moveLeft() {
    let moved = false;
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 1; col < GRID_SIZE; col++) {
            if (board2048[row][col] !== 0) {
                let currentCol = col;
                while (currentCol > 0 && (board2048[row][currentCol - 1] === 0 || board2048[row][currentCol - 1] === board2048[row][currentCol])) {
                    if (board2048[row][currentCol - 1] === 0) {
                        board2048[row][currentCol - 1] = board2048[row][currentCol];
                        board2048[row][currentCol] = 0;
                        currentCol--;
                        moved = true;
                    } else if (board2048[row][currentCol - 1] === board2048[row][currentCol]) {
                        board2048[row][currentCol - 1] *= 2;
                        board2048[row][currentCol] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function moveRight() {
    let moved = false;
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = GRID_SIZE - 2; col >= 0; col--) {
            if (board2048[row][col] !== 0) {
                let currentCol = col;
                while (currentCol < GRID_SIZE - 1 && (board2048[row][currentCol + 1] === 0 || board2048[row][currentCol + 1] === board2048[row][currentCol])) {
                    if (board2048[row][currentCol + 1] === 0) {
                        board2048[row][currentCol + 1] = board2048[row][currentCol];
                        board2048[row][currentCol] = 0;
                        currentCol++;
                        moved = true;
                    } else if (board2048[row][currentCol + 1] === board2048[row][currentCol]) {
                        board2048[row][currentCol + 1] *= 2;
                        board2048[row][currentCol] = 0;
                        moved = true;
                        break;
                    }
                }
            }
        }
    }
    return moved;
}

function isGameOver() {
    // 檢查是否還有空格
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            if (board2048[i][j] === 0) return false;
        }
    }
    
    // 檢查是否還有可以合併的相方塊
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            if (i < GRID_SIZE - 1 && board2048[i][j] === board2048[i + 1][j]) return false;
            if (j < GRID_SIZE - 1 && board2048[i][j] === board2048[i][j + 1]) return false;
        }
    }
    
    return true;
}

// 俄羅斯方塊遊戲邏輯
let tetrisBoard, currentPiece, nextPiece, tetrisInterval, currentX, currentY;
const TETRIS_BLOCK_SIZE = 20;
const BOARD_WIDTH = 12;
const BOARD_HEIGHT = 20;

function startTetrisGame() {
    const canvas = document.getElementById('tetrisCanvas');
    canvas.width = BOARD_WIDTH * TETRIS_BLOCK_SIZE;
    canvas.height = BOARD_HEIGHT * TETRIS_BLOCK_SIZE;
    canvas.focus();
    tetrisBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
    currentPiece = getRandomPiece();
    nextPiece = getRandomPiece();
    currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
    currentY = 0;
    clearInterval(tetrisInterval);
    tetrisInterval = setInterval(() => {
        const canvas = document.getElementById('tetrisCanvas');
        updateTetrisGame(canvas.getContext('2d'));
    }, 500);
    drawTetrisBoard(canvas.getContext('2d'));
}

function getRandomPiece() {
    const pieces = [
        [[1,1,1,1]],
        [[1,1],[1,1]],
        [[1,1,1],[0,1,0]],
        [[1,1,1],[1,0,0]],
        [[1,1,1],[0,0,1]],
        [[1,1,0],[0,1,1]],
        [[0,1,1],[1,1,0]]
    ];
    return pieces[Math.floor(Math.random() * pieces.length)];
}

function drawTetrisBoard(ctx) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // 繪製已放置的方塊
    for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            if (tetrisBoard[y][x]) {
                ctx.fillStyle = 'blue';
                ctx.fillRect(x * TETRIS_BLOCK_SIZE, y * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
            }
        }
    }
    
    // 繪製當前方塊
    ctx.fillStyle = 'red';
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x]) {
                ctx.fillRect((x + currentX) * TETRIS_BLOCK_SIZE, (y + currentY) * TETRIS_BLOCK_SIZE, TETRIS_BLOCK_SIZE - 1, TETRIS_BLOCK_SIZE - 1);
            }
        }
    }
}

function updateTetrisGame(ctx) {
    if (!canMovePieceDown()) {
        placePiece();
        if (isGameOverTetris()) {
            clearInterval(tetrisInterval);
            const score = calculateTetrisScore();
            alert('遊戲結束！您的分數是：' + score);
            saveScore('tetris', score);
            endGame('tetris');
            return;
        }
        currentPiece = nextPiece;
        nextPiece = getRandomPiece();
        currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
        currentY = 0;
    } else {
        currentY++;
    }
    drawTetrisBoard(ctx);
}

function handleTetrisKeyPress(e) {
    if (activeGame !== 'tetris') return;
    
    switch(e.key) {
        case 'ArrowLeft':
            moveTetrisPieceLeft();
            break;
        case 'ArrowRight':
            moveTetrisPieceRight();
            break;
        case 'ArrowDown':
            moveTetrisPieceDown();
            break;
        case 'ArrowUp':
            rotateTetrisPiece();
            break;
    }
    
    const canvas = document.getElementById('tetrisCanvas');
    drawTetrisBoard(canvas.getContext('2d'));
}

// 添加這些輔助函數
function moveTetrisPieceLeft() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x] && (x + currentX - 1 < 0 || tetrisBoard[y + currentY][x + currentX - 1])) {
                return;
            }
        }
    }
    currentX--;
}

function moveTetrisPieceRight() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x] && (x + currentX + 1 >= BOARD_WIDTH || tetrisBoard[y + currentY][x + currentX + 1])) {
                return;
            }
        }
    }
    currentX++;
}

function moveTetrisPieceDown() {
    if (!canMovePieceDown()) {
        placePiece();
        return;
    }
    currentY++;
}

function rotateTetrisPiece() {
    const rotatedPiece = currentPiece[0].map((val, index) => currentPiece.map(row => row[index]).reverse());
    if (canPieceFit(rotatedPiece, currentX, currentY)) {
        currentPiece = rotatedPiece;
    }
}

function canMovePieceDown() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x] && (y + currentY + 1 >= BOARD_HEIGHT || tetrisBoard[y + currentY + 1][x + currentX])) {
                return false;
            }
        }
    }
    return true;
}

function canPieceFit(piece, x, y) {
    for (let pieceY = 0; pieceY < piece.length; pieceY++) {
        for (let pieceX = 0; pieceX < piece[pieceY].length; pieceX++) {
            if (piece[pieceY][pieceX]) {
                if (pieceX + x < 0 || pieceX + x >= BOARD_WIDTH || pieceY + y >= BOARD_HEIGHT || tetrisBoard[pieceY + y][pieceX + x]) {
                    return false;
                }
            }
        }
    }
    return true;
}

function placePiece() {
    for (let y = 0; y < currentPiece.length; y++) {
        for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x]) {
                tetrisBoard[y + currentY][x + currentX] = 1;
            }
        }
    }
    clearLines();
    currentPiece = nextPiece;
    nextPiece = getRandomPiece();
    currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
    currentY = 0;
    if (!canPieceFit(currentPiece, currentX, currentY)) {
        endGame('tetris');
    }
}

function clearLines() {
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (tetrisBoard[y].every(cell => cell !== 0)) {
            tetrisBoard.splice(y, 1);
            tetrisBoard.unshift(Array(BOARD_WIDTH).fill(0));
        }
    }
}

function isGameOverTetris() {
    return !canMovePieceDown() && currentY === 0;
}

function calculateTetrisScore() {
    let score = 0;
    for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            if (tetrisBoard[y][x]) {
                score++;
            }
        }
    }
    return score;
}

// 添加 guessNumber 函數
let targetNumber, guessCount;

function guessNumber() {
    const guess = parseInt(document.getElementById('guessNumberInput').value);
    guessCount++;
    
    if (guess === targetNumber) {
        document.getElementById('guessResult').textContent = `Congratulations! You guessed it in ${guessCount} tries.`;
        saveScore('guessNumber', guessCount);
        endGame('guessNumber');
    } else if (guess < targetNumber) {
        document.getElementById('guessResult').textContent = 'Too low, guess higher!';
    } else {
        document.getElementById('guessResult').textContent = 'Too high, guess lower!';
    }
}

// 添加 playRPS 函數
function playRPS(playerChoice) {
    const choices = ['Rock', 'Scissors', 'Paper'];
    const computerChoice = choices[Math.floor(Math.random() * 3)];
    
    let result;
    if (playerChoice === computerChoice) {
        result = 'It\'s a tie!';
    } else if (
        (playerChoice === 'Rock' && computerChoice === 'Scissors') ||
        (playerChoice === 'Scissors' && computerChoice === 'Paper') ||
        (playerChoice === 'Paper' && computerChoice === 'Rock')
    ) {
        result = 'You win!';
    } else {
        result = 'Computer wins!';
    }
    
    document.getElementById('rpsResult').textContent = `You chose ${playerChoice}, computer chose ${computerChoice}. ${result}`;
}

// 修改 saveScore 函數
function saveScore(game, score) {
    let id = document.getElementById(`${game}Id`).value.trim();
    if (!id) {
        id = 'noname';
    }
    const scoreRef = database.ref('scores').push();
    scoreRef.set({
        game: game,
        id: id,
        score: score
    });
    updateScoreTable();
}

// 添加 updateScoreTable 函數
function updateScoreTable() {
    const scoresRef = database.ref('scores');
    scoresRef.orderByChild('score').limitToLast(10).on('value', (snapshot) => {
        const scores = [];
        snapshot.forEach((childSnapshot) => {
            scores.push(childSnapshot.val());
        });
        scores.reverse();
        
        const tableBody = document.getElementById('scoreTableBody');
        tableBody.innerHTML = '';
        scores.forEach((score) => {
            const row = tableBody.insertRow();
            row.insertCell(0).textContent = score.game;
            row.insertCell(1).textContent = score.id;
            row.insertCell(2).textContent = score.score;
        });
    });
}

// 在頁面加載時調用 updateScoreTable
window.onload = function() {
    updateScoreTable();
};
</script>
</body>
</html>

